## Ejercicio 1
---
(A) El invariante vale en la pre pero no en la post de todas las funciones de la interfaz.
     Falso, el invariante debe valer antes y despues de cada funcion de la interfaz.
(B) El invariante vale en la pre y en la post de todas las funciones de implmentacion que se corresponden con            funciones de la interfaz.
    Verdadero, el invariante debe valer antes y despues de cada funcion de la interfaz.
(C) El invariante vale en la pre y la post de todas las funciones auxiliares de la implementacion.
     Falso. No necesariamente, en ocasiones estas funciones solo son para reducir el codigo en las funciones de la interfaz por lo que son "bloques".
(D) La funcion de abstraccion provee una explicacion de como se usa la estructura de representacion.
     Verdadero. Usando los observadores podemos entender que componentes de la estructura se asocian al tad.
(E) Falso, solo nos provee la informacion de como se representa pero no nos habla de su comportamiento.

## Ejercicio 2
---
Datos:
- 3 botones: AM, FM y SW.
- 2 botones: Subir 10hz y Bajar 10hz.
- Cada vez que se cambia de banda, se vuelve a la frecuencia en la que estaba esa banda.
- 5 botones para memorizar estaciones.
- Si se lo pulsa por 2 segundos, se memoriza la banda, si no, se va a esa.

Errores:
- No tenemos una lista de las freciuencias memorizadas.
- No se guarda la frecuencia de las bandas en las que se la dejaron.

TAD ultimasFrecuencias es tupla(frecuencia, frecuencia, frecuencia) (AM, FM, SW)
TAD estacion es tupla(banda, frecuencia)
TAD estaciones es secu(estacion)

Observadores:
banda: estereo -> nat
frecuencia: estereo -> nat
bandas: estereo -> ultimasFrecuencias
memorizadas: estereo -> estaciones

Generadores:
frecuencia(nuevo) = 0
frecuencia(cambiar_frecuencia(e, f)) = frecuencia(e) + f
frecuencia(cambiar_banda(e, b)) = if b == 0 
                                                         then $\pi_{1}$(bandas(e))
                                                    else
                                                       if b == 1
                                                          then $\pi_{2}$(bandas(e))
                                                        else
                                                          $\pi_{3}$(bandas(e))
frecuencia(presionar_boton_dos_segundos(e, boton)) = if boton == 0 then prim(mermorizadas(e)) = tupla(banda(e, frecuencia(e))
presionar_boton(e, boton) = Actual = prim(memorizadas(e))

## Ejercicio 5
---

- InsertionSort: Es igual, guardamos un puntero al nodo actual cuando insertamos un elemento en nuestro array ya ordenado. Seguimos hasta que el siguiente sea nulo.
- SelectionSort: Es igual, swapear dos nodos es constante.
- Bucket Sort, counting sort, radix sort: Se complica el tema de acceder a al indice al que pertenece. En vez de ser acceso constante, tenemos que tener un contador que nos diga en que indice estamos. En este caso la k de constante pasa a ser un n.
- mergesort: Aca el problema es la recursion. Para dividr en arrays separados debemos conocer el largo total del array actual recorriendolo en O(n) para luego buscar la mitad de n y luego recorrer n/2 para settear el ultimo de la mitad izquierda a null y el primero de la mitad derecha a null. Mergear los arrays seria igual que en el algoritmo normal.
- quicksort: igual que el merge.