## Ejercicio 1
---
El sistema de especificación TAD' es muy similar a los TADs que se utilizan en la materia, pero su única igualdad entre instancias se define así: dos instancias son iguales si y solo si aplicando axiomas se puede llegar de una a la otra.

1. Este sistema de especificación no tiene uno de los problemas formales más importantes que puede tener un TAD. ¿Cuál? ¿Por qué?
2. ¿Qué dificultad presenta la especificación del TAD' conjunto en este formalismo?

Respuestas:		
 1. El problema de la congruencia. En este caso tenemos un registro de como se formo una instancia del tad, entonces sabemos diferenciar exactamente entre instancias.
 2. La igualdad "axiomatizal" seria horrible de especificar!
 
 ##  Ejercicio 2
 ---
 Explique la relación entre invariante de representación y complejidad algorítmica, y entre función de abstracción y la demostración de que el diseño es correcto con respecto a la especificación.

 - En algunas estructuras el invariante nos verifica ciertas propiedades, estas propiedades me dan una cota para la complejidad de ciertas operaciones en el modulo.

## Ejercicio 3
---
Se desea implementar un TAD que permita representar un conjunto de números racionales, donde a las tradicionales operaciones de Agregar(S,x) y Borrar(S,x) se agrega la siguiente: CLOSERTOAVG(S), que toma como input un conjunto S y devuelve el valor contenido en S más cercano al promedio de los valores contenidos en S. Discutir la implementación de este TAD utilizando variantes de al menos 4 estructuras de datos vistas en clase para representar conjuntos/diccionarios standard.

- Tupla<arreglo, nat>
- Busqueda binaria para encontrar el mas cercano al promedio.

## Ejercicio 5
---
Se cuenta con n elementos que contienen una clave primaria y una secundaria. Hay m<<n claves secundarias distintas. Proponga dos formas eficientes y distintas que permitan ordenar los n elementos, en base a las dos claves (primero la primaria, luego la secundaria).

- Mergesort sobre las claves secundarias, luego mergesort sobre las calves primarias. Al ser mergesort un algoritmo de ordenamiento estable, se mantiene el orden relativo.
- Creo el operador '<' para los nodos tupla<clavePrimaria,claveSecundaria>. Este compara por calve primaria y luego secundaria. Uso heapify para convertir el arreglo de nodos en un heap y luego desencolo el mas grande n veces.